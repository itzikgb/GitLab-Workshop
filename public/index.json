[
{
	"uri": "/10_getting_started/1_aws_event_engine.html",
	"title": "AWS Event Engine",
	"tags": [],
	"description": "",
	"content": " Logging into AWS Event Engine To complete this workshop, you are provided with an AWS account via the AWS Event Engine service. A 12-digit hash will be provided to you by event staff - this is your unique access code. eg:\ne8476543c00e  Go to https://dashboard.eventengine.run to log into AWS Event Engine.   Enter your unique 12-digit hash code and choose Accept Terms \u0026amp; Login.   Choose AWS Console, then Open AWS Console.  This account will expire at the end of the workshop and the all the resources created will be automatically deprovisioned. You will not be able to access this account after today.\nRegion selection Use a single region for the duration of this workshop. This workshop supports the following regions:\n us-west-2 (US West - Oregon)  Please select US West - Oregon in the top right corner.\n"
},
{
	"uri": "/5_overview.html",
	"title": "GitLab - DevOps Platform",
	"tags": [],
	"description": "",
	"content": " GitLab - the open DevOps platform GitLab helps you to iterate faster, innovate together.\nOur open DevOps platform is a single application for collaboration, visibility, and development velocity.\n✅ One user interface to learn\n✅ One place to manage and control access\n✅ One place to track and audit compliance\n✅ One place to automate pipelines to ensure quality and security\n✅ One place to manage and orchestrate deployments to production\n✅ One place to plan and manage the product backlog\n✅ One place to prioritize business goals and epics\u0026mdash;and then track through delivery.\n⭐ Only GitLab can cover all the bases in a single application and streamline your application delivery practices and processes. "
},
{
	"uri": "/5_overview/agile.html",
	"title": "Agile Management",
	"tags": [],
	"description": "",
	"content": " Agile Planning and Management By empowering teams, embracing change, and focusing on delivering value, Agile methodologies have transformed software development. Agile teams create more relevant, valuable, customer-centric products, more quickly than ever.\nDevelopment teams accelerate the delivery of value with iterative, incremental, and lean project methodologies including Scrum, Kanban, Extreme Programming (XP), and more. Large enterprises have adopted Agile at enterprise scale through a variety of frameworks, including Scaled Agile Framework (SAFe), Spotify, Large Scale Scrum (LeSS), and others. GitLab enables teams to apply Agile practices and principles to organize and manage their work, whatever their chosen methodology. These new methodologies bring new challenges.\nAgile is not a single methodology, but a set of guiding principles embraced by many methodologies in many ways. There is no single “best” way to plan and manage an Agile enterprise, and older project planning tools are often insufficiently flexible to address the needs of a given implementation.\nThis functionality gap leads to poor project estimation, planning, and progress tracking. Furthermore, Agile methodologies can create confusion between teams and throughout the enterprise, where even well-documented Agile processes may not map to traditional success metrics and waterfall financial planning.\nOragnizations need better ways to manage projects, programs, and portfolios using Agile. They need to better:\n plan and prioritize work based on strategic objectives initiate work monitor the progress of that work in progress collaborate on work, across teams, throughout the product lifecycle control and optimize the flow of work close work items when completed measure the value created by that work communicate that value throughout the organization, regardless of other methodologies in place  "
},
{
	"uri": "/10_getting_started/2_aws_account.html",
	"title": "AWS Account",
	"tags": [],
	"description": "",
	"content": " You are responsible for the cost of the AWS services used while running this workshop in your AWS account.\n Your account must have the ability to create new IAM roles and scope other IAM permissions.\n If you already have an AWS account, and have IAM Administrator access, go to Provision VPC \u0026amp; Cloud9\n Create an account  If you don\u0026rsquo;t already have an AWS account with Administrator access: create one now\n Once you have an AWS account, ensure you are following the remaining workshop steps as an IAM user with administrator access to the AWS account: Create a new IAM user to use for the workshop\n Enter the user details:  Attach the AdministratorAccess IAM Policy:  Click to create the new user:  Take note of the login URL and save:   Provision VPC Click here to deploy using CloudFormation template\n Create stack, click Next Specify stack details, click Next Configure stack options, click Next Review UnicornDevSecOpsWorkshop, scroll to bottom section under Capabilities and check both boxes and click Create stack  The installation takes a few minutes. Please continue to the next section.\n "
},
{
	"uri": "/34_lab4/configuration.html",
	"title": "Configure the .gitlab-ci.yml file in the project",
	"tags": [],
	"description": "",
	"content": " Configure the CI/CD in the project In the root of the project you imported in lab2 there is already .gitlab-ci.yml file that includes build and test stages, and jobs in each stage.\nWe will add one additional job to this configuration file, deploy:\n deploy will deploy the sample website to S3.  Open the Web IDE. On the left, open the .gitlab-ci.yml file. You will notice stages keyword, with build, test and deploy stages.\nstages: - build - test - deploy Scroll down, and create a deploy job in the deploy stage.\n Job name: deploy to s3 stage: deploy add the following scripts:  curl \u0026quot;https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip\u0026quot; -o \u0026quot;awscliv2.zip\u0026quot; unzip -q awscliv2.zip ./aws/install aws s3 cp ./public s3://mytestwebsite211/ --recursive   Replace mytestwebsite211 with your bucket name.\n Your deploy job should look like this one:\ndeploy to s3: stage: deploy script: - curl \u0026#34;https://awscli.amazonaws.com/awscli-exe-linux-x86_64.zip\u0026#34; -o \u0026#34;awscliv2.zip\u0026#34; - unzip -q awscliv2.zip - ./aws/install - aws s3 cp ./public s3://mytestwebsite211/ --recursive Commit the change, click Commit.  Add a commit message.\n Change the default commit option to Commit to master branch.\n Click Commit.   Wait a few seconds until you will see in the status bar, below the commit button, the pipeline ID, click on it in order to open the pipeline. This will open the Pipeline graph. You can click on each job to check its log. Wait until the deploy to s3 job completes, when it has a green V icon.\nMake sure all jobs passed successfully, and that pipeline status is passed. ✅ Well done! Your pipeline just built, tested and deployed the sample website to S3. Open in the browser the domain of our S3 Bucket, and you will be able to see the website. "
},
{
	"uri": "/20_workshop_info.html",
	"title": "Workshop info",
	"tags": [],
	"description": "",
	"content": " workshop schedule    LAB # LAB Title Time Allocated     Lab1 Stand-up GitLab Ultimate 20 min   Lab2 Prepare your GitLab environment 30 min   Lab3 Prepare the production target 30 min   BREAK Use this time to catch up 10 min   Lab4 CI/CD configuration 20 min   Lab5 Development flow: change code, build, test, and deploy 20 min    Summary and cleanup 10 mins    "
},
{
	"uri": "/10_getting_started.html",
	"title": "Getting Started",
	"tags": [],
	"description": "",
	"content": " Getting Started Click here if you are at an AWS event where the Event Engine is being used\n Click here if you are running this individually in your own AWS Account\n "
},
{
	"uri": "/31_lab1.html",
	"title": "Lab1 - Stand-up GitLab Ultimate",
	"tags": [],
	"description": "",
	"content": " In This lab we will spin-up GitLab Ultimate AMI in AWS. Pre requisites for this lab is having an accessible and working VPC.\n ✅ Step-by-step Instructions\n Open GitLab Ultimate in AWS Marketplace. Click on Continue to Subscribe  Sign in with your IAM user.  Click on Continue to Configuration.  Leave the default value for Delivery Method, Select the latest version in Software Version, Select your Region, click Continue to Launch.  In Lunch this software page, scroll down.  Under Security Group Settings click Create New Based On Seller Settings .  Name your security group, add a description, and Save it.  Select Key Pair. If you don\u0026rsquo;t have key pair, create one. Leave other fields in this page with default values. Click Launch.  You will get Congratulations message confirming you launched the machine successfully. In this message click on EC2 Console link.  Click on your instance ID link. The provisioning takes a few minutes. Please wait before you start the next step.\n  Click Open address in order to open GitLab UI. Copy the private or public IP to your browser , depending on your VPC configuration.\n   - It takes a few minutes to start the server, you may see this error, this is ok, wait 1 minute and refresh the page. - You are now should be able to access GitLab login page. username is root, password is your instance ID, click Sign in. ✅ Congratulations! you managed to start GitLab instance and sign in to it. "
},
{
	"uri": "/5_overview/vcc.html",
	"title": "Version Control and Collaboration (VC&amp;C)",
	"tags": [],
	"description": "",
	"content": " Version Control and Collaboration (VC\u0026amp;C)  As organizations accelerate delivery, through DevOps, controlling and managing different versions of the application assets from code to configuration and from design to deployment is incredibly important. Velocity without robust version control and traceability is like driving a car with out a seatbelt.\nVersion Control and Collaboration is more than simply tracking changes, versions, and branches of code. Effectively, it includes practices such as:\n Enabling development teams to work in distributed and asynchronous environments Managing changes and versions of code and artifacts Enabling Review and Collaboration of code and other assets Tracking approvals of proposed changes Resolving merge conflicts and related anomalies  In general, Version Control and Collaboration is required because software is constantly changing. Regardless of the stage of development, there will be change to deal with.\n"
},
{
	"uri": "/5_overview/ci.html",
	"title": "Continuous Integration (CI)",
	"tags": [],
	"description": "",
	"content": " Continuous Integration (CI)  The Continuous Integration (CI) use case is a staple of modern software development in the digital age. It\u0026rsquo;s unlikely that you hear the word \u0026ldquo;DevOps\u0026rdquo; without a reference to \u0026ldquo;Continuous Integration and Continuous Delivery\u0026rdquo; (CI/CD) soon after. In the most basic sense, the CI part of the equation enables development teams to automate building and testing their code.\nWhen practicing CI, teams collaborate on projects by using a shared repository to store, modify and track frequent changes to their codebase. Developers check in, or integrate, their code into the repository multiple times a day and rely on automated tests to run in the background. These automated tests verify the changes by checking for potential bugs and security vulnerabilities, as well as performance and code quality degradations. Running tests as early in the software development lifecycle as possible is advantageous in order to detect problems before they intensify.\nCI makes software development easier, faster, and less risky for developers. By automating builds and tests, developers can make smaller changes and commit them with confidence. They get earlier feedback on their code in order to iterate and improve it quickly increasing the overall pace of innovation. Studies done by DevOps Research and Assessment (DORA) have shown that robust DevOps practices lead to improved business outcomes. All of these \u0026ldquo;DORA 4\u0026rdquo; metrics can be improved by using CI:\n Lead time: Early feedback and build/test automation help decrease the time it takes to go from code committed to code successfully running in production.\n Deployment frequency: Automated build and test is a pre-requisite to automated deploy.\n Time to restore service: Automated pipelines enable fixes to be deployed to production faster reducing Mean Time to Resolution (MTTR)\n Change failure rate: Early automated testing greatly reduced the number of defects that make their way out to production. GitLab CI/CD comes built-in to GitLab\u0026rsquo;s complete DevOps platform delivered as a single application. There\u0026rsquo;s no need to cobble together multiple tools and users get a seamless experience out-of-the-box.\n  "
},
{
	"uri": "/32_lab2.html",
	"title": "Lab2 - Prepare your GitLab environment",
	"tags": [],
	"description": "",
	"content": " Prepare your GitLab environment In this lab we will create a new project in GitLab by importing an existing repository. Then, we will install GitLab Runner, the agent that runs the CI/CD jobs, and register it to the project we just created.\nFor more information about creating projects in GitLab, visit https://docs.gitlab.com/ee/user/project/working_with_projects.html\n "
},
{
	"uri": "/5_overview/devsecops.html",
	"title": "DevSecOps (Shift Left Security)",
	"tags": [],
	"description": "",
	"content": " DevSecOps The DevSecOps usecase is applicable for customers who are trying to \u0026ldquo;shift left\u0026rdquo; to find security vulnerabilities earlier within their DevOps methodology but have not been able to achieve expected results.\nApplication Security is hard when security is separated from your DevOps flow. Security has traditionally been the final hurdle in the development life cycle. Iterative development workflows can make security a release bottleneck. Customers don\u0026rsquo;t have enough security people to test all of their code, and hiring more security analysts won\u0026rsquo;t automatically reduce the friction between app sec and engineering teams. Only testing major releases, or limiting tests to certain apps, leaves weak spots hackers can exploit. They need a way to balance risk and business agility. Instead of waiting for security at the end of the development process, they want to include it within their DevOps workflow. Often this is referred to as DevSecOps.\nDevSecOps integrates security controls and best practices in the DevOps workflow. DevSecOps automates security and compliance workflows to create an adaptable process for your development and security teams.\nWhy is DevSecOps needed? Balancing business velocity with security is possible. With GitLab, DevSecOps architecture is built into the CI/CD process. Every merge request is scanned through its pipeline for security issues and vulnerabilities in the code and its dependencies using automated tests. This enables some magic to happen.\nBenefits of DevSecOps Every piece of code is tested upon commit for security threats, without incremental cost. The developer can remediate now, while they are still working in that code, or create an issue with one click. The dashboard for the security pro is a roll-up of vulnerabilities remaining that the developer did not resolve on their own. Vulnerabilities can be efficiently captured as a by-product of software development. A single tool also reduces cost over the approach to buy, integrate and maintain point solutions throughout the DevOps pipeline.\n"
},
{
	"uri": "/32_lab2/import_project.html",
	"title": "Import repository",
	"tags": [],
	"description": "",
	"content": "We will import an existing sample application developed in gatsby.\n Click New project.  Select Import project  Select Repo by URL  Under Git repository URL, enter this URL https://gitlab.com/tech-marketing/my-static-website.git.  Scroll down and click Create project.  The import takes a few seconds. ✅ Well done! You successfully created project in your GitLab instance.  "
},
{
	"uri": "/5_overview/cd.html",
	"title": "Continuous Delivery (CD)",
	"tags": [],
	"description": "",
	"content": " Continuous Delivery “Deployment is manual”\n“Functional tests are manual”\n“Time consuming or lack of rollback on performance degradation or production errors”\n“Hard to maintain environment configurations and hard to operate”\n“No consistency in deployment process”\n“Manual / hard coded configurations”\n“No standardized software artifact”\n“No release management in place”\n“Too dependent on other teams to get any release done”\nIf these are the typical problems you face, Continuous Delivery is for you.\nContinuous Delivery is the next logical step after continuous integration and it streamlines and automates the application release process to make software delivery repeatable and on demand - from provisioning the infrastructure environment to deploying the tested application software to test/staging or production environments. Organizations practicing continuous delivery are able to plan their release processes and schedules, automate infrastructure and application deployments, manage deployed infrastructure and application resources resources, and analyze metrics to optimise the software delivery process.\nWhy Continuous Delivery? Consistent \u0026amp; repeatable release process - lesser manual processes imply the release process is less error prone and hence can be repeatable for every minimal change to the code\nFaster time to market - automation of environment provisioning, software deployment and rapid feedback helps teams to iterate faster and rollback when necessary\nLower risk releases - by using progressive delivery practices such as advanced deployments: incremental / blue green / canary deployments, review apps, feature flags and a deployment performance feedback loop, organizations are able to validate their software before widespread deployment\n"
},
{
	"uri": "/32_lab2/runner.html",
	"title": "Install and register Runner",
	"tags": [],
	"description": "",
	"content": " ⭐Lab Objectives Runner machines are the build agents that run the CI/CD jobs. We will install GitLab Runner and Docker engine. We run all jobs inside the images, and therefore the runner machine requires Docker engine on the runner machine.\nWe will configure the Runner and register it to work with our GitLab project.\nRunning jobs inside container has several advantages: Jobs are isolated which avoid compatibility issues, and they run in a secured environment. Once a job completes, the image is being destroyed and nothing is left on the runner machine. Also, you don\u0026rsquo;t need to install any build tool on the runner machine, all prerequisite tools available in the standard or custom Docker image. For more information about running jobs in docker containers, visit https://docs.gitlab.com/ee/ci/docker/using_docker_images.html#run-your-cicd-jobs-in-docker-containers\n It is not recommended best practice to install Runners on the same machine when the server installed for security and performance reasons, but only for the sake of simplicity, in this workshop we will install it on the same machine.\n GitLab Runner is open-source and written in Go. It can be run as a single binary; no language-specific requirements are needed. You can install GitLab Runner on several different supported operating systems. Other operating systems may also work, as long as you can compile a Go binary on them.\n Install Docker engine  Go to your Instance summary, and click Connect in order to open the console. In order to setup the Runners we need to connect to the Gitlab machine we are running. This can be done via SSH from any command line, or directly via the AWS Console, depending on your VPC is set. In our example we will use the AWS console - Connect feature to SSH into the machines.\n  Click Connect again.  Install Container by running this command curl -fsSL https://get.docker.com -o get-docker.sh sudo sh get-docker.sh  Setup Runners  Download the binaries for Linux x86 sudo curl -L --output /usr/local/bin/gitlab-runner \u0026quot;https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-linux-386\u0026quot; Give it permissions to execute: sudo chmod +x /usr/local/bin/gitlab-runner Create a GitLab CI user: sudo useradd --comment 'GitLab Runner' --create-home gitlab-runner --shell /bin/bash Install and run as service: sudo gitlab-runner install --user=gitlab-runner --working-directory=/home/gitlab-runner sudo gitlab-runner start  Register the Runner  Run this command: sudo gitlab-runner register. You will be prompt to enter URL. Open your GitLab instance, under CI/CD settings:  Click Settings-\u0026gt;CI/CD.  Expand Runners.  Copy the URL to the clipboard under specific runner.   Pater the URL in the console. Enter. You will be prompt to enter registration token, copy it from the Runner settings.  Paste it in the console. Enter Description for the runner: type GitLab workshop. Add a tag to this runner, for example type Linux Enter executor, type docker. Enter the default Docker image, type ruby:2.6. You will get a message starting with Runner registered successfully. Feel free to start it\u0026hellip; Refresh the Runner settings page in GitLab and you will see your runner under Available specific runners. Click edit.  Check the Indicates whether this runner can pick jobs without tags option, and click Save changes.   ✅Well done!! you installed and registered successfully GitLab Runner.\n"
},
{
	"uri": "/33_lab3.html",
	"title": "Lab3 - Prepare the production target for application deployment",
	"tags": [],
	"description": "",
	"content": " Setting Up an S3 Bucket to Host our target. We will use an S3 bucket to host our deployed web site. For that we have to create the following:\n Create IAM role that allows our runner to access S3. Attach our created role to our Gitlab Machine. Create an S3 bucket. Set the bucket for Static Hosting to allow public access to our site.  We are going to create a publicly accessiable S3 bucket. This bucket will be accessibale from the internet, and shoudnlt be used to store anything else, other than the sample site in this workshop.\n "
},
{
	"uri": "/33_lab3/iam_policy.html",
	"title": "Create an IAM Policy",
	"tags": [],
	"description": "",
	"content": " Create an IAM Policy for the Gitlab Runner. In order to be able to deploy our website to an S3 bucket we need to allow our runner to access S3. We do that with an EC2 Instance policy that we attach to our Gitlab Instance.\n In the AWS Console we select from the upper bar \u0026ldquo;Services\u0026rdquo; - \u0026gt; \u0026ldquo;IAM\u0026rdquo;\n In the IAM Page we select \u0026ldquo;Roles\u0026rdquo; From the left side then \u0026ldquo;Create Role\u0026rdquo;.  In the Create Role Page, leave Select type of trusted entity set to AWS service. Under Common use cases, Select EC2 to create an instance profile, , then click \u0026ldquo;Next\u0026rdquo;  In the Attach Permissions Polices Page use the search bar to look for AmazonS3FullAccess Policy, Then Click Next  On the Tags page, add any optional tags you might want, then click Next  In the review page, enter a name for the policy and a description. then click Create Role   Next, we will attach our new Role to the EC2 machine that runs Gitlab. "
},
{
	"uri": "/5_overview/gitops.html",
	"title": "GitOps",
	"tags": [],
	"description": "",
	"content": " GitOps The need for GitOps Modern applications are developed with rapid iteration and run at highly dynamic scale. In an organization with a mature DevOps culture code can be deployed to production hundreds of times per day. Applications can then run under highly dynamic loads from a few users to millions. Modern infrastructure needs to be elastic. Capacity that can be dynamically provisioned and de-provisioned is able to keep pace with load maintaining optimal performance and minimal cost. With the demands made on today\u0026rsquo;s infrastructure it\u0026rsquo;s becoming increasingly crucial manage infrastructure automation with a robust and cohesive methodology.\nWhat is GitOps? GitOps == IaC + MRs + CI/CD\nGitOps is an operational framework that takes DevOps best practices used for application development such as version control, collaboration, compliance, and CI/CD, and applies them to infrastructure automation.\n GitOps involves managing your IT infrastructure using practices well-known in software development such as version control, code review, and CI/CD pipelines. For example, infrastructure teams that practice GitOps use configuration files stored as code. Similar to how application source code generates the same application binaries every time it\u0026rsquo;s built, GitOps configuration generates the same infrastructure environment every time it is deployed.\n IaC - GitOps uses a Git repository as the single source of truth for infrastructure definition. Infrastructure as Code (IaC) is the practice of keeping all infrastructure configuration stored as code. The actual desired state may or may not be not stored as code (e.g., number of replicas, pods).\n MRs - GitOps uses Merge Requests (MRs) as the change mechanism for all infrastructure updates. The MR is where teams can collaborate via reviews and comments and where formal approvals take place. Merge commits to your master(or trunk) branch serve as a change log for auditing and troubleshooting.\n CI/CD - GitOps automates infrastructure updates using a Git workflow with Continuous Integration and Continuous Delivery (CI/CD). When new code is merged, the CI/CD pipeline enacts the change in the environment. Any configuration drift, such as manual changes or errors, is overwritten by GitOps automation so the environment converges on the desired state defined in Git. GitLab uses CI/CD pipelines to manage and implement GitOps automation, but other forms of automation such as definitions operators could be used as well.\n  As with any emerging technology term, \u0026ldquo;GitOps\u0026rdquo; isn\u0026rsquo;t strictly defined the same way by everyone across the industry. GitOps emerged in the cloud native community and some definitions restrict GitOps to say \u0026ldquo;Kubernetes is required to be doing GitOps.\u0026rdquo; GitLab takes a broader approach. We\u0026rsquo;ve seen GitLab users and customers applying GitOps principals to all types of infrastructure automation including VMs and containers, as well as Kubernetes clusters.\nWhile many tools and methodologies promise faster deployment and seamless management between code and infrastructure, GitOps differs by focusing on a developer-centric experience. Infrastructure management through GitOps happens in the same version control system as the application development, enabling teams to collaborate more in a central location while benefiting from all the built-in features of Git.\nGitOps is a prescriptive workflow for using Infrastructure as Code. GitOps with GitLab helps you manage physical, virtual and cloud native infrastructures (including Kubernetes and serverless technologies) using tight integration with industry-leading infrastructure automation tools like Terraform, AWS Cloud Formation, Ansible, Chef, Puppet, and the like.\nBenefits of GitOps Distribution of work - Enable more engineers to collaborate on infrastructure changes. Since every change will go through the same change/merge request/review/approval/merge process, this enables senior engineers to focus on other areas beyond the critical infrastructure management while still maintaining the ability to review and contribute as needed.\n Improved access control There\u0026rsquo;s no need to give credentials to all infrastructure components since changes are automated only by your CI/CD needs access.\n Faster time to market - execution via code is faster than manual point and click, test cases can be automated and hence repeatable in a consistent manner to deliver stable environments rapidly, at scale\n Less risk The shift-left approach to infrastructure as Code helps to identify and resolve issues before changes are rolled out to production preempting unexpected downtime and providing higher environment stability and reliability and better user experience.\n More compliant All changes to infrastructure are tracked, leaving traceability for audit and ability to rollback to a previous desired state with ease.\n Reduce costs - automation of infrastructure definition and testing eliminates manual tasks and rework improving productivity, reduced downtimes due to built in revert/rollback capability\n Less error prone - infrastructure definition is codified, hence repeatable and less prone to human error\n  Push vs Pull GitOps (Agentless vs Agent Based GitOps) As with any emerging technologies, there are different approaches to GitOps, each with their own pros and cons.\nPush or Agentless GitOps In this approach, your CI/CD tool pushes the changes to your environment. This approach is consistent with the approach used for application deployment. Pro\nEase of use. Well-known CI/CD - build, test, \u0026amp; deploy all use the same tech Deployment targets not limited to cloud native / Kubernetes only - can deploy to physical, virtual container - whether onpremise or cloud etc. Con Need to open your firewall to your cluster and grant admin access to external CI/CD\nPull or Agent Bsed GitOps In this approach, an agent is installed in your cluster to pull changes whenever there is a drift from the desired configuration. Pro\nSecure infrastructure - no need to open your firewall or grant admin access externally Con Agent needs to be installed in every cluster Limited to k8s-only Uses different technology than application CI/CD\n"
},
{
	"uri": "/34_lab4.html",
	"title": "Lab4 - CI/CD configuration",
	"tags": [],
	"description": "",
	"content": " CI/CD configuration In GitLab, the CI/CD configuration is made via code. In order to enable CI/CD, you need to create .gitlab-ci.yml file in YAML format, and save it in the root of your repository.\nIn this file, you define:\n The structure and order of jobs that the runner should execute. The decisions the runner should make when specific conditions are encountered.  For example, you might want to run a suite of tests when you commit to any branch except the default branch. When you commit to the default branch, you want to run the same suite, but also publish your application.\nAll of this is defined in the .gitlab-ci.yml file.\n"
},
{
	"uri": "/33_lab3/iam_attach.html",
	"title": "Attach IAM Policy To Gitlab Runner",
	"tags": [],
	"description": "",
	"content": " Attach IAM Policy To Gitlab Runner For the Gitlab runner to use the role we just create, we must attach it to the EC2 Machine that runs our Runner. In our case our Gitlab Server.\n In the AWS Console we select from the upper bar Services - \u0026gt; EC2, and open our instance.  Select our Gitlab machine, then click Actions -\u0026gt; Security -\u0026gt; Modify IAM Role.  From the dropdown in the page that opened select the role we create in the previous step. Then click Save.   Next, we will create an S3 that will store our website. "
},
{
	"uri": "/35_lab5.html",
	"title": "LAB5 - Development flow: change code, build, test, and deploy",
	"tags": [],
	"description": "",
	"content": " Development flow: change code, build, test, and deploy Now that we have a project configured with CI/CD that build, test and deploy the app, we can make a change to the website, test, and deploy it\nFrom the project overview page, open the Web IDE. From the left pane, open the file index.js under /src/pages Modify the code, replace the text Now go build something great with With GitLab you can iterate faster, innovate together: Our open DevOps platform is a single application for unparalleled collaboration, visibility, and development velocity.\nCommit the change, click Commit.\n Add a Commit message.\n Change the default commit option to Commit to master branch.\n Click Commit.\n  Wait for the pipeline to complete.\n✅ Well done! You manages to run through a full development flow with GitLab CI/CD!\nCheck the website to see your change deployed.\n"
},
{
	"uri": "/33_lab3/s3_create.html",
	"title": "Create and S3 Bucket and Setup Static Hosting",
	"tags": [],
	"description": "",
	"content": " Create and S3 Bucket and Setup Static Hosting To host our site we will leverage S3 Static Hosting capability. First, we need to create an S3 bucket.\n In the AWS Console we select from the upper bar Services - \u0026gt; S3\n On The S3 page, select Buckets then Create Bucket.  Give the bucket a unique name, then scroll down to the Block Public Access settings section.  In the Block Public Access settings section, Remove the check box next to Block all public access, and add a check box at bottom to acknowledge public access.  Scroll down and click Create Bucket.\n  Next, we will setup our bucket for static hosting.  From the bucket list, select our new bucket.\n Then click Properties.  In the page that opened scroll all the way down, until you reach Static website hosting, and click Edit.  Select Enable in the configuration page, and write index.htm under the index document.  Scroll down and select Save Changes.\n Back in the properties page, under Static website hosting, you will now see the link to our static website.   Finally, we will set the bucket policy to enable public access.  On our bucket page click Permissions.  Then scroll down to Bucket Policy and click Edit.  Paste the following policy and change BUCKET_NAME to your S3 bucket name.\n{ \u0026#34;Version\u0026#34;: \u0026#34;2012-10-17\u0026#34;, \u0026#34;Statement\u0026#34;: [ { \u0026#34;Sid\u0026#34;: \u0026#34;PublicReadGetObject\u0026#34;, \u0026#34;Effect\u0026#34;: \u0026#34;Allow\u0026#34;, \u0026#34;Principal\u0026#34;: \u0026#34;*\u0026#34;, \u0026#34;Action\u0026#34;: \u0026#34;s3:GetObject\u0026#34;, \u0026#34;Resource\u0026#34;: \u0026#34;arn:aws:s3:::BUCKET_NAME/*\u0026#34; } ] } Click Save Changes , and this will redirect you back the bucket page. Where you should see an indicator that the bucket is now publicaly accessiable.   We are all set to deploy our website . "
},
{
	"uri": "/40_summary.html",
	"title": "Summary",
	"tags": [],
	"description": "",
	"content": " Summary In this workshop we learned:  How to stand-up GitLab Ultimate in AWS via the marketplace. How to install GitLab Runner and register it to our GitLab project. How to create a new project and import a repository to it. How to configure GitLab CI/CD via the .gitlab-ci.yml file. How to use GitLab DevOps platform to build, test and deploy applications.  Cleanup We have create several resources in this workshop and we want to make sure that we remove them after we are done experimenting, so not incurs additional charges.\nS3 Bucket Removal  In our AWS Console, Click Services -\u0026gt; S3. Select the bucket we created earlier, and click the Delete button on the upper right corner. You will get error message saying the bucket is not empty. Click on the link empty bucket configuration in that message. Confirm the bucket deletion by entering permanently delete in the input field. Then click Empty. Confirm that the bucket was delete by making sure its not on the bucket list.  EC2 Machine Removal  In our AWS Console, Click Services -\u0026gt; EC2. Select Instances from the left hand side, and select our Gitlab machine from the list. Click the Instance State button on the right hand side, and choose Terminate instance. Click Terminate in the dialog that opens, to confirm.  Marketplace Subscription Removal  In our AWS Console, Click Services -\u0026gt; AWS Marketplace Subscriptions. Under the Gitlab Ultimate subscription, click the Manage button. Click the Actions button on the right hand side and select Cancel Subscription. In the dialog that comes up, check the check box, and click Yes, cancel subscription.  "
},
{
	"uri": "/categories.html",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/",
	"title": "GitLab DevOps Modernization Workshop",
	"tags": [],
	"description": "",
	"content": " DevOps Modernization Workshop Welcome In this workshop you will learn about the GitLab DevOps platform and how to build, test, and deploy features and functionality at a faster pace.\nLearning Objectives  Stand up a self managed instance of GitLab. Create a project, import a sample source code. Create deployment target in S3. Configure CI/CD pipeline. Change the code, run the pipeline which will build, test and deploy the new code to production.  The GitLab environment we will build is a non production grade setup. For the sake of simplicity of this workshop, we use one machine for the entire setup, we don’t use clusters and Load Balancer, we install GitLab server and the Runner on the same machine.  "
},
{
	"uri": "/tags.html",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]